import puppeteer from 'puppeteer';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import Application from '../models/Application.js';
import Job from '../models/Job.js';
import UserProfile from '../models/UserProfile.js';
import logger from '../utils/logger.js';

const sleep = promisify(setTimeout);

class ExternalJobApplicationService {
  constructor() {
    this.browser = null;
    this.page = null;
  }

  async initializeBrowser() {
    if (!this.browser) {
      this.browser = await puppeteer.launch({
        headless: true,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-gpu',
          '--window-size=1920x1080'
        ]
      });
    }
    
    if (!this.page) {
      this.page = await this.browser.newPage();
      await this.page.setViewport({ width: 1920, height: 1080 });
      await this.page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');
    }
  }

  async closeBrowser() {
    if (this.page) {
      await this.page.close();
      this.page = null;
    }
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  // Main function to apply to external job
  async applyToExternalJob(jobId, userId, applicationData = {}) {
    try {
      const job = await Job.findById(jobId);
      const userProfile = await UserProfile.findOne({ user: userId }).populate('user');
      
      if (!job || !userProfile) {
        throw new Error('Job or user profile not found');
      }

      const { coverLetter, resumePath, autoApply = false } = applicationData;

      let applicationResult = null;

      // Determine application strategy based on job source
      switch (job.source.toLowerCase()) {
        case 'linkedin':
          applicationResult = await this.applyToLinkedInJob(job, userProfile, { coverLetter, resumePath, autoApply });
          break;
        case 'indeed':
          applicationResult = await this.applyToIndeedJob(job, userProfile, { coverLetter, resumePath, autoApply });
          break;
        case 'glassdoor':
          applicationResult = await this.applyToGlassdoorJob(job, userProfile, { coverLetter, resumePath, autoApply });
          break;
        default:
          applicationResult = await this.applyToGenericJob(job, userProfile, { coverLetter, resumePath, autoApply });
      }

      // Create application record
      const application = await Application.create({
        userId,
        jobId,
        coverLetter: coverLetter || '',
        status: applicationResult.success ? 'applied' : 'failed',
        applicationSource: job.source.toLowerCase(),
        externalApplicationData: {
          applicationId: applicationResult.applicationId || null,
          platformUrl: applicationResult.applicationUrl || job.externalUrl,
          autoApplied: autoApply,
          applicationStatus: applicationResult.status || 'submitted',
          platformResponse: applicationResult.response || ''
        },
        appliedViaAgent: autoApply,
        agentMetadata: autoApply ? {
          agentVersion: '1.0.0',
          confidenceScore: applicationResult.confidence || 0.8,
          matchingScore: applicationResult.matchScore || 0.7,
          autoGeneratedCoverLetter: !coverLetter
        } : undefined
      });

      // Update job application tracking
      await Job.findByIdAndUpdate(jobId, {
        $inc: {
          'applicationTracking.totalApplications': 1,
          'applicationTracking.externalApplications': 1
        }
      });

      return {
        success: applicationResult.success,
        application,
        message: applicationResult.message || 'Application submitted successfully',
        applicationUrl: applicationResult.applicationUrl
      };

    } catch (error) {
      logger.error('Error applying to external job:', error);
      throw error;
    }
  }

  // LinkedIn application logic
  async applyToLinkedInJob(job, userProfile, options = {}) {
    try {
      await this.initializeBrowser();
      
      // Navigate to LinkedIn job
      await this.page.goto(job.externalUrl || job.sourceUrl, { 
        waitUntil: 'networkidle2' 
      });

      await sleep(2000);

      // Look for Easy Apply button
      const easyApplyButton = await this.page.$('button[aria-label*="Easy Apply"]');
      
      if (!easyApplyButton) {
        // If no Easy Apply, check for external application
        const externalApplyButton = await this.page.$('a[data-tracking-control-name="public_jobs_apply_link"]');
        if (externalApplyButton) {
          const externalUrl = await this.page.evaluate(el => el.href, externalApplyButton);
          return await this.applyToGenericJob({ ...job, externalUrl }, userProfile, options);
        }
        throw new Error('No application button found');
      }

      if (!options.autoApply) {
        // Return application URL for manual application
        return {
          success: true,
          message: 'LinkedIn Easy Apply available - manual application required',
          applicationUrl: job.externalUrl || job.sourceUrl,
          requiresManualApplication: true
        };
      }

      // Auto-apply logic (requires LinkedIn login)
      await easyApplyButton.click();
      await sleep(3000);

      // Check if login is required
      const loginForm = await this.page.$('form[data-id="sign-in-form"]');
      if (loginForm) {
        throw new Error('LinkedIn login required for auto-application');
      }

      // Fill application form
      await this.fillLinkedInApplicationForm(userProfile, options);

      return {
        success: true,
        message: 'Applied to LinkedIn job successfully',
        applicationId: `linkedin_${Date.now()}`,
        confidence: 0.9
      };

    } catch (error) {
      logger.error('LinkedIn application error:', error);
      return {
        success: false,
        message: error.message,
        applicationUrl: job.externalUrl || job.sourceUrl
      };
    }
  }

  // Indeed application logic
  async applyToIndeedJob(job, userProfile, options = {}) {
    try {
      await this.initializeBrowser();
      
      await this.page.goto(job.externalUrl || job.sourceUrl, { 
        waitUntil: 'networkidle2' 
      });

      await sleep(2000);

      // Look for Indeed Apply button
      const applyButton = await this.page.$('[data-jk="indeedApply"]') || 
                          await this.page.$('button[aria-label*="Apply"]') ||
                          await this.page.$('.ia-BaseSalaryApplyButton');

      if (!applyButton) {
        // Check for external application link
        const externalLink = await this.page.$('a[data-jk="applyButtonLinkContainer"]');
        if (externalLink) {
          const externalUrl = await this.page.evaluate(el => el.href, externalLink);
          return await this.applyToGenericJob({ ...job, externalUrl }, userProfile, options);
        }
        throw new Error('No application method found');
      }

      if (!options.autoApply) {
        return {
          success: true,
          message: 'Indeed application available - manual application required',
          applicationUrl: job.externalUrl || job.sourceUrl,
          requiresManualApplication: true
        };
      }

      // Auto-apply logic
      await applyButton.click();
      await sleep(3000);

      // Fill Indeed application form
      await this.fillIndeedApplicationForm(userProfile, options);

      return {
        success: true,
        message: 'Applied to Indeed job successfully',
        applicationId: `indeed_${Date.now()}`,
        confidence: 0.85
      };

    } catch (error) {
      logger.error('Indeed application error:', error);
      return {
        success: false,
        message: error.message,
        applicationUrl: job.externalUrl || job.sourceUrl
      };
    }
  }

  // Generic job board application
  async applyToGenericJob(job, userProfile, options = {}) {
    try {
      await this.initializeBrowser();
      
      await this.page.goto(job.externalUrl || job.sourceUrl, { 
        waitUntil: 'networkidle2' 
      });

      await sleep(2000);

      // Look for common application patterns
      const applySelectors = [
        'button[type="submit"]',
        'input[type="submit"]',
        'a[href*="apply"]',
        'button[class*="apply"]',
        '.apply-button',
        '#apply-btn',
        '[data-test="apply-button"]'
      ];

      let applyButton = null;
      for (const selector of applySelectors) {
        applyButton = await this.page.$(selector);
        if (applyButton) break;
      }

      if (!applyButton) {
        return {
          success: true,
          message: 'External application available - manual application required',
          applicationUrl: job.externalUrl || job.sourceUrl,
          requiresManualApplication: true
        };
      }

      if (!options.autoApply) {
        return {
          success: true,
          message: 'Application available - manual application required',
          applicationUrl: job.externalUrl || job.sourceUrl,
          requiresManualApplication: true
        };
      }

      // Attempt auto-fill for generic forms
      await this.fillGenericApplicationForm(userProfile, options);

      return {
        success: true,
        message: 'Applied to job successfully',
        applicationId: `generic_${Date.now()}`,
        confidence: 0.7
      };

    } catch (error) {
      logger.error('Generic application error:', error);
      return {
        success: false,
        message: error.message,
        applicationUrl: job.externalUrl || job.sourceUrl
      };
    }
  }

  // LinkedIn form filling helper
  async fillLinkedInApplicationForm(userProfile, options = {}) {
    try {
      // Wait for form to load
      await this.page.waitForSelector('.jobs-easy-apply-modal', { timeout: 10000 });

      // Fill basic information
      const nameInput = await this.page.$('input[name="name"]');
      if (nameInput) {
        await nameInput.clear();
        await nameInput.type(`${userProfile.personalInfo.firstName} ${userProfile.personalInfo.lastName}`);
      }

      const emailInput = await this.page.$('input[name="email"]');
      if (emailInput) {
        await emailInput.clear();
        await emailInput.type(userProfile.user.email);
      }

      const phoneInput = await this.page.$('input[name="phone"]');
      if (phoneInput && userProfile.personalInfo.phone) {
        await phoneInput.clear();
        await phoneInput.type(userProfile.personalInfo.phone);
      }

      // Upload resume if available
      const resumeInput = await this.page.$('input[type="file"]');
      if (resumeInput && options.resumePath) {
        await resumeInput.uploadFile(options.resumePath);
      }

      // Fill cover letter
      const coverLetterTextarea = await this.page.$('textarea[name="coverLetter"]');
      if (coverLetterTextarea && options.coverLetter) {
        await coverLetterTextarea.clear();
        await coverLetterTextarea.type(options.coverLetter);
      }

      // Submit application
      const submitButton = await this.page.$('button[type="submit"]');
      if (submitButton) {
        await submitButton.click();
        await sleep(3000);
      }

    } catch (error) {
      logger.error('Error filling LinkedIn form:', error);
      throw error;
    }
  }

  // Indeed form filling helper
  async fillIndeedApplicationForm(userProfile, options = {}) {
    try {
      // Wait for form elements
      await sleep(2000);

      // Fill name
      const nameInput = await this.page.$('input[data-testid="applicant-name"]');
      if (nameInput) {
        await nameInput.clear();
        await nameInput.type(`${userProfile.personalInfo.firstName} ${userProfile.personalInfo.lastName}`);
      }

      // Fill email
      const emailInput = await this.page.$('input[data-testid="applicant-email"]');
      if (emailInput) {
        await emailInput.clear();
        await emailInput.type(userProfile.user.email);
      }

      // Fill phone
      const phoneInput = await this.page.$('input[data-testid="applicant-phone"]');
      if (phoneInput && userProfile.personalInfo.phone) {
        await phoneInput.clear();
        await phoneInput.type(userProfile.personalInfo.phone);
      }

      // Upload resume
      const resumeInput = await this.page.$('input[type="file"]');
      if (resumeInput && options.resumePath) {
        await resumeInput.uploadFile(options.resumePath);
      }

      // Submit
      const submitButton = await this.page.$('button[data-testid="submit-application"]');
      if (submitButton) {
        await submitButton.click();
        await sleep(3000);
      }

    } catch (error) {
      logger.error('Error filling Indeed form:', error);
      throw error;
    }
  }

  // Generic form filling helper
  async fillGenericApplicationForm(userProfile, options = {}) {
    try {
      // Common input patterns
      const inputMappings = [
        { selectors: ['input[name*="name"]', '#name', '.name'], value: `${userProfile.personalInfo.firstName} ${userProfile.personalInfo.lastName}` },
        { selectors: ['input[name*="first"]', '#firstName', '.first-name'], value: userProfile.personalInfo.firstName },
        { selectors: ['input[name*="last"]', '#lastName', '.last-name'], value: userProfile.personalInfo.lastName },
        { selectors: ['input[name*="email"]', '#email', '.email'], value: userProfile.user.email },
        { selectors: ['input[name*="phone"]', '#phone', '.phone'], value: userProfile.personalInfo.phone || '' },
        { selectors: ['textarea[name*="cover"]', '#coverLetter', '.cover-letter'], value: options.coverLetter || '' }
      ];

      for (const mapping of inputMappings) {
        for (const selector of mapping.selectors) {
          const input = await this.page.$(selector);
          if (input && mapping.value) {
            await input.clear();
            await input.type(mapping.value);
            break;
          }
        }
      }

      // Upload resume
      const resumeInput = await this.page.$('input[type="file"]');
      if (resumeInput && options.resumePath) {
        await resumeInput.uploadFile(options.resumePath);
      }

    } catch (error) {
      logger.error('Error filling generic form:', error);
      throw error;
    }
  }

  // Save job for later application
  async saveJobForLater(jobId, userId) {
    try {
      const existingApplication = await Application.findOne({
        userId,
        jobId,
        savedAt: { $exists: true }
      });

      if (existingApplication) {
        throw new Error('Job already saved');
      }

      const application = await Application.create({
        userId,
        jobId,
        status: 'saved',
        savedAt: new Date(),
        applicationSource: 'internal'
      });

      return {
        success: true,
        application,
        message: 'Job saved successfully'
      };

    } catch (error) {
      logger.error('Error saving job:', error);
      throw error;
    }
  }

  // Get saved jobs
  async getSavedJobs(userId) {
    try {
      const savedApplications = await Application.find({
        userId,
        status: 'saved',
        savedAt: { $exists: true }
      })
      .populate('jobId')
      .sort({ savedAt: -1 });

      return {
        success: true,
        savedJobs: savedApplications,
        message: 'Saved jobs fetched successfully'
      };

    } catch (error) {
      logger.error('Error fetching saved jobs:', error);
      throw error;
    }
  }
}

export default new ExternalJobApplicationService();
